const apps = {}; // holds all injected Vue apps
const topic = Configurator.group; // values sourced from config.json
const poll_topic = topic +"_poll_topic";
const question_topic = topic + "_question_topic";
const meta_topic = topic + "_meta_topic";
//java-2022_poll_topic

console.log("Do this together..");
Reveal.on( 'slidechanged', async event => {
    if(!isPoll(event.currentSlide)) return

    // For each poll a vue app is injected into the slides
    const currentSlideIndex = event.indexh;
    if(!isPollInitialized(currentSlideIndex)){
        // Vue app is populated based on the markdown in ".poll" annotated containers (inject overwrites all contents in that container)
        let questionList = extractContentFromMarkdown(event);
        apps[currentSlideIndex] = inflateVueApp(questionList);
    }
});

function inflateVueApp(questions) {
    return new Vue({
        el: '.present .poll',
        data: {
            questionId: "",
            questions: questions,
            questionResponses: Array(questions.length).fill(0),
        },
        template:
            `
                <ul>
                    <li v-for="(question, index) in questions" style="list-style-type: none; font-size: 1em; display: flex;align-items: center; flex-direction: row-reverse; flex-wrap: wrap">
                        <span class="badge" style="flex: 1">{{questionResponses[index]}}</span>
                        <span style="flex: 8"> {{question}} </span>
                    </li>                    
                </ul>
                `,
        async mounted() {
            // Broadcast questions
            await this.broadcastQuestions(questions);
            // Listen for participant answers
            this.subscribeToPollingAnswers();
        },
        methods: {
            broadcastQuestions: async function (questions) {
                const questionRequest = {
                    topic: question_topic,
                    message: base64({event: "question_event", questions: questions}),
                    title: "Polling event",
                    tags: [],
                    attach: ""
                };
                let response = await axios.post("https://ntfy.sh", questionRequest);
                this.questionId = response.data.id; // id is generated by ntfy backend
            },
            subscribeToPollingAnswers: function () {
                // All vue app listen to all answers from all polls
                const eventSource = new EventSource(`https://ntfy.sh/${poll_topic}/sse`);
                eventSource.onmessage = (eventWrapper) => {
                    const event = JSON.parse(eventWrapper.data);
                    const message = base64Decode(event.message);
                    // But here is filtered if the poll actually maps to the published question id
                    if(message.question_id === this.questionId) {
                        this.questionResponses = this.questionResponses.map((total, index) => total += message.voting[index]);
                    }
                }
            }
        },
        // Not yet needed
        'questions': function (val, oldVal) {
            console.log('question changed: %s, old: %s', val, oldVal)
        },
    });
}


function isPoll(currentSlide) {
    return currentSlide.querySelector('.present .poll') !== null;
}

function base64(payload) {
    return btoa(JSON.stringify(payload));
}

function base64Decode(payloadString) {
    return JSON.parse(atob(payloadString));
}

function extractContentFromMarkdown(event) {
    const pollContent = event.currentSlide.cloneNode(true);
    let answerList = Array.from(
        pollContent.querySelector('.poll ul')
            .getElementsByTagName("li"))
        .map((e) => e.textContent.trim());
    return answerList;
}
function isPollInitialized(index) {
    // Refactor results in a very spare array (a lot of undefined), better use map
    return apps[index];
}